import asyncio
import random
from contextlib import asynccontextmanager
from pathlib import Path
from typing import Any

import aiofiles
from aiodocker import Docker
from aiodocker.containers import DockerContainer
from nanoid import generate
from pydantic import BaseModel

from src.auth import AuthUser
from src.logs import logger
from src.settings import settings

UNASSIGNED_USER_NAME = "UNASSIGNED"
FRIENDLY_CHARS: str = "23456789abcdefghijkmnpqrstuvwxyz"


class ContainerMetadata(BaseModel):
    user: AuthUser


class Container:
    """
    Wrapper around a DockerContainer.
    Container names are [USER_NAME]-[HOSTNAME] or UNASSIGNED-[HOSTNAME]
    """

    def __init__(self, container: DockerContainer):
        self.container = container

    @property
    def id(self) -> str:
        return self.container.id[:12]

    @property
    def hostname(self) -> str:
        container_name = self.container._container["Names"][0].strip("/")  # type: ignore[reportUnknownMemberType]
        return container_name.split("-")[-1]

    @classmethod
    def name_for_user(cls, user: AuthUser | None, hostname: str) -> str:
        return f"{user.user_name if user else UNASSIGNED_USER_NAME}-{hostname}"

    @property
    def mount_dir(self) -> Path:
        return self.mount_dir_for_hostname(self.hostname)

    @classmethod
    def mount_dir_for_hostname(cls, hostname: str) -> Path:
        path = settings.server_mount_parent_dir / hostname
        if not path.exists():
            path.mkdir(parents=True, exist_ok=True)
        return path

    @property
    def metadata_file(self) -> Path:
        return self.metadata_file_for_hostname(self.hostname)

    @classmethod
    def metadata_file_for_hostname(cls, hostname: str) -> Path:
        return cls.mount_dir_for_hostname(hostname) / "metadata.json"


class ServerManager:
    """
    Manages the lifecycle and routing of containers.

    === Containers ===
    - Containers run the settings.SERVER_IMAGE service in the same network as the gateway and proxy services.
    - Container identifiers:
      - CONTAINER_ID: the id of the container, auto created by Docker.
      - HOSTNAME: the network hostname of the container, random string generated by nanoid.
      - CONTAINER_NAME: the name of the container, UNASSIGNED-[HOSTNAME] for unassigned containers
          and [USER_NAME]-[HOSTNAME] for assigned containers, where assigned USER_NAME is AuthUser.user_name.
      - USER_HOSTNAME: an alias of network hostname, equals to AuthUser.user_name.
    - Containers can be reached by HOSTNAME and USER_HOSTNAME on the network with settings.DOCKER_DOMAIN.

    === Lifecyle and Routing ===
    - The pool maintains a list of settings.MIN_SERVER_POOL_SIZE unassigned containers.
    - When a new user connects, the manager will assign a container from the pool to the user, and backfill the pool.
    - When an existing user connects
      - via MCP, the request is routed to the container by USER_HOSTNAME (AuthUser.user_name).
      - via hosted link, the request is routed to the container by the link_id, where it encodes HOSTNAME.
    """

    @classmethod
    async def get_user_hostname(cls, user: AuthUser) -> str:
        """Get the hostname of the user's container. Assign one if not exists."""
        async with docker_client() as docker:
            if not await cls._user_has_container(user, docker=docker):
                await cls._assign_container(user, docker=docker)
                await cls.backfill_container_pool(docker=docker)
        return cls.external_hostname(user.user_name)

    @classmethod
    async def get_unassigned_server_host(cls) -> str:
        container = await cls._get_random_unassigned_container()
        return cls.external_hostname(container.hostname)

    @classmethod
    def external_hostname(cls, hostname: str) -> str:
        """Hostname of the container that can be reached from outside of Docker network."""
        return f"{hostname}.{settings.DOCKER_DOMAIN}"

    @classmethod
    async def reload_containers(cls):
        # List all directories in the server mount directory
        mount_dirs = cls._get_mount_dirs()
        async with docker_client() as docker:
            await asyncio.gather(
                *[cls._create_container(mount_dir=item, docker=docker) for item in mount_dirs],
            )
            await cls.backfill_container_pool(docker=docker)

        logger.info(f"Reloaded {len(mount_dirs)} containers")

    @classmethod
    async def backfill_container_pool(cls, *, docker: Docker | None = None):
        async with docker_client(docker) as _docker:
            containers = await cls._get_containers(prefix=UNASSIGNED_USER_NAME, docker=_docker)
            num = settings.MIN_CONTAINER_POOL_SIZE - len(containers)
            if num <= 0:
                return
            logger.info(f"Backfill server pool with {num} servers")
            await asyncio.gather(*[cls._create_container(docker=_docker) for _ in range(num)])

    @classmethod
    async def _user_has_container(cls, user: AuthUser, *, docker: Docker | None = None) -> bool:
        containers = await cls._get_containers(prefix=user.user_name, docker=docker)
        return len(containers) != 0

    @classmethod
    async def _get_containers(cls, *, prefix: str, docker: Docker | None = None):
        async with docker_client(docker) as docker:
            containers = await docker.containers.list(  # type: ignore[reportUnknownMemberType]
                filters={"ancestor": [settings.SERVER_IMAGE], "name": [prefix]}
            )
        return [Container(container) for container in containers]

    @classmethod
    async def _get_random_unassigned_container(cls, docker: Docker | None = None):
        containers = await cls._get_containers(prefix=UNASSIGNED_USER_NAME, docker=docker)
        if not containers:
            raise ValueError("No unassigned containers found")
        container = random.choice(containers)
        logger.info(f"Randomly selected unassigned container {container.id}")
        return container

    @classmethod
    def _get_mount_dirs(cls):
        return [item for item in settings.server_mount_parent_dir.iterdir() if item.is_dir()]

    @classmethod
    def _generate_container_name(cls) -> str:
        """Generate a random name until it is not in the existing names."""
        mount_dirs = cls._get_mount_dirs()
        existing_names = set(item.stem for item in mount_dirs)
        while (name := generate(FRIENDLY_CHARS, 6)) in existing_names:
            continue
        return name

    @classmethod
    async def _create_container(
        cls, *, mount_dir: Path | None = None, docker: Docker | None = None
    ):
        """Create a fresh container for UNASSIGNED user or load from a mount_dir for an existing user."""
        if mount_dir is None:
            hostname = cls._generate_container_name()
            user = None
        else:
            hostname = mount_dir.stem
            metadata = await cls._read_metadata(hostname)
            user = metadata.user if metadata else None

        container_name = Container.name_for_user(user, hostname)
        containers = await cls._get_containers(prefix=container_name, docker=docker)
        if containers:
            logger.info(f"Container {container_name} already exists")
            return hostname

        src_data_dir = str(Container.mount_dir_for_hostname(hostname))
        dst_data_dir = "/app/data"
        network_aliases = [cls.external_hostname(hostname)]
        if user:
            network_aliases.append(cls.external_hostname(user.user_name))

        # tailscale router is need to access proxy service
        tailscale_router_ip = f"{settings.DOCKER_SUBNET_PREFIX}.2"

        config: dict[str, Any] = {
            "Image": settings.SERVER_IMAGE,
            "Entrypoint": ["/bin/sh", "-c"],  # override the entrypoint to add tailscale routing
            "Cmd": [
                "apt update && apt install -y iproute2 &&"
                f" ip route add 100.64.0.0/10 via {tailscale_router_ip} &&"
                " exec /app/entrypoint.sh"
            ],
            "Env": [
                f"LOG_LEVEL={settings.LOG_LEVEL}",
                "BROWSER_TIMEOUT=300000",
                f"BROWSER_HTTP_PROXY={settings.BROWSER_HTTP_PROXY}",
                f"BROWSER_HTTP_PROXY_PASSWORD={settings.BROWSER_HTTP_PROXY_PASSWORD}",
                f"OPENAI_API_KEY={settings.OPENAI_API_KEY}",
                f"SENTRY_DSN={settings.SERVER_SENTRY_DSN}",
                f"DATA_DIR={dst_data_dir}",
                f"HOSTNAME={hostname}",
                "PORT=80",
            ],
            "HostConfig": {"Binds": [f"{src_data_dir}:{dst_data_dir}:rw"], "CapAdd": ["NET_ADMIN"]},
            "NetworkingConfig": {
                "EndpointsConfig": {cls._network_name(): {"Aliases": network_aliases}}
            },
        }

        async with docker_client(docker) as docker:
            container = await docker.containers.run(  # type: ignore[reportUnknownMemberType]
                config, name=container_name
            )
            logger.info(f"Created server hostname: {hostname}, id: {container.id[:12]}")
        return hostname

    @classmethod
    async def _assign_container(cls, user: AuthUser, *, docker: Docker | None = None):
        async with docker_client(docker) as docker:
            # rename the container to [AuthUser.user_name]-[HOSTNAME]
            container = await cls._get_random_unassigned_container(docker)
            assigned_container_name = f"{user.user_name}-{container.hostname}"
            await container.container.rename(assigned_container_name)  # type: ignore[reportUnknownMemberType]

            await cls._write_metadata(container, user)

            # add HOSTNAME and USER_HOSTNAME (AuthUser.user_name) to the container network aliases
            network = await docker.networks.get(cls._network_name())
            await network.disconnect({"Container": container.id})
            await network.connect({  # type: ignore[reportUnknownMemberType]
                "Container": container.id,
                "EndpointConfig": {
                    "Aliases": [
                        cls.external_hostname(container.hostname),
                        cls.external_hostname(user.user_name),
                    ]
                },
            })
            logger.info(f"Assigned container {container.id} to {user.user_name}")

        return user.user_name

    @classmethod
    async def _write_metadata(cls, container: Container, user: AuthUser):
        metadata = ContainerMetadata(user=user)
        async with aiofiles.open(container.metadata_file, "w") as f:
            await f.write(metadata.model_dump_json())

    @classmethod
    async def _read_metadata(cls, hostname: str) -> ContainerMetadata | None:
        path = Container.metadata_file_for_hostname(hostname)
        if not path.exists():
            return None  # ignore unassigned container

        async with aiofiles.open(path, "r") as f:
            metadata = ContainerMetadata.model_validate_json(await f.read())
        return metadata

    @classmethod
    def _network_name(cls):
        return f"{settings.DOCKER_PROJECT_NAME}_{settings.DOCKER_NETWORK_NAME}"

    @classmethod
    def _user_server_host(cls, user: AuthUser) -> str:
        return f"{user.login}.{user.auth_provider}"


@asynccontextmanager
async def docker_client(client: Docker | None = None):
    nested = client is not None

    _client = client or Docker()
    try:
        yield _client
    finally:
        if not nested:
            await _client.close()
